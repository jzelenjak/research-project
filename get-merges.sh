#!/bin/bash
# Gets the nodes affected by a merge during the FlexFringe PDFA learning process for each merge iteration and combines the results into a single PDF file.
#
# This script analyses testXXXX.dot files generated by FlexFringe, which are printed before every merge (set `debug = 1`, also `printwhite = 1` and `printblue = 1`).
#   Note: `print_dot` method in `apta.cpp` in FlexFringe has to use `APTA_iterator` to ensure consistent numbering of all nodes throughout the dot files.
#
# The script filters out only the states that have been affected by a merge, i.e. the states that have changed their:
#   - representatives
#   - count (frequency), or
#   - degree (number of incoming and outgoing edges)
# It skips the merges where nothing happened (i.e. blue nodes have been coloured to red and their white children to blue),
#     since they are not interesting and are large.
# For each merge, it combines the affected "before" and "after" fragments of the PDFA into one image
#     and finally combines all of them into one PDF file.
# If you also want to see the outgoing edges for each node, you can comment out the if checks from the lines:
#   - `if ($.name == edge1.head.name) clone(before, edge1);
#   - `if ($.name == edge2.head.name) clone(after, edge2);
#   Note that `img2pdf` will most likely fail to create the final PDF due to the large size of some images. You will still have the png images with the merges, though.
#   I cannot also guarantee the full correctness of the images. Nevertheless, I hope that this will be useful to get more insights into the merges.
#
# To facilitate the analysis, extra enhancements have been applied:
#   - `The red and blue nodes that have been merged at the beginning of an iteration` are coloured **much darker** and have **white font colour**.
#     Furthermore, they are have **a very thick yellow border**. `The incoming edge on which they have been merged` is also **yellow** and **thick**.
#     This enhancement is applied to both "before" and "after" fragments.
#   - `Children of the blue node that have been merged during the determinization process` are **slightly thick**, **dashed** and ** brown**.
#     Furthermore, `the incoming edges on which they have been merged` are also **slightly thick**, **dashed** and **brown**.
#     This enhancement is applied only to the "after" fragment.
#   - `Children of the red node that have been merged during the determinization process` are **slightly thick**, **solid** and ** brown**.
#     Furthermore, `the incoming edges on which they have been merged` are also **slightly thick**, **solid** and **brown**.
#     This enhancement is applied only to the "after" fragment.
#   - Finally, for every affected node, its incoming edges, together with their endpoints, are displayed to create some context.
#     This enhancement is applied to both "before" and "after" fragments. 
#   - Note: the thickness and colours are customizable and can be changed if needed. NB! Red, blue and white colours used by FlexFringe should not be changed!
#
# To facilitate the analysis even further, the script prints some very useful logs about the performed merges:
#       - The red node that has been merged and its count (before the merge)
#       - The blue node that has been merged and its count (before the merge)
#       - The (incoming) edge with `mcat|mserv` on which these nodes have been merged
#       - Nodes merged during the determinization process and their counts (after the merge),
#         together with the incoming edge on which they have been merged
#       - The merge iteration and the page number (they do not correspond to each other as some merges are skipped)
#         (e.g. might be useful when analysing the log file using `grep` or `awk`)
# You can process the log file with other commands like `grep` to pinpoint interesting merges and further analyse them in the PDF file.
# The logs can be found in the file "merges.log" (by default). Feel free to give a different name to the `log_file` variable below.

set -euo pipefail
IFS=$'\n\t'

umask 077

usage() {
    echo -e "Usage: $0 [output.pdf]"  # By default, `merges.pdf` file will be used for output
}

# Store the output file name if specified
out="merges.pdf"
[[ $# -eq 1 ]] && out="$1"

# File with the logs
log_file="merges.log"

# Check if the dependencies are present
img2pdf --help > /dev/null
convert --help > /dev/null

# Customizable parameters for the gvpr script
sink_count=5
colour_init_merge="darkgoldenrod1"
colour_det_merge="chocolate4"
red="firebrick1"
dark_red="firebrick4"
red_prefix="firebrick"
blue="dodgerblue1"
dark_blue="dodgerblue4"
white="ghostwhite"
thickness_init_merge="10"
thickness_det_merge="5"

# Iterate over each consecutive pair of testXXXX.dot files to get a "smart" diff
num_tests=$(find . -type f -name '*test*.dot' | wc -l)
curr_page=1
for t in $(seq 1 $((num_tests - 1))); do
    # Create variables tor test files and test numbers
    t1=$(printf "%04d" $t)
    t2=$(printf "%04d" $((t + 1)))
    test1="test${t1}.dot"
    test2="test${t2}.dot"

    # Check if the test files exist
    [[ -f "$test1" ]] || { echo "$0: file $test1 does not exist" >&2 ; exit 1 ; }
    [[ -f "$test2" ]] || { echo "$0: file $test2 does not exist" >&2 ; exit 1 ; }

    # Create variables for temporary files
    merge_before="merge${t1}-before"
    merge_before_dot="merge${t1}-before.dot"
    merge_before_png="merge${t1}-before.png"
    merge_after="merge${t1}-after"
    merge_after_dot="merge${t1}-after.dot"
    merge_after_png="merge${t1}-after.png"
    merge_png="merge${t1}.png"

    # Get a "smart" diff for the current merge iteration
    echo "Merge $t" | tee -a "$log_file"
    gvpr 'BEGIN {
            // Function definitions

            // Format of a node in the PDFA
            // "0x56409e3fc870:#
            //  rep#0x56409e2917d0
            //  892 #10"

            // Get the representative of a node given its label
            string get_representative(node_t n) {
                if (n.name == "I") return "I";                          // Skip the artificial "I" node as it has no label
                string label = gsub(gsub(n.label, "\r"), "\n", "|");    // Put the label on one line
                int start_cut = index(label, "rep#") + 4;               // Find the starting index of the cut
                int end_cut = rindex(label, "|");                       // Find the ending index of the cut
                return substr(label, start_cut, end_cut - start_cut);   // Return the representative
            }

            // Get the name of a node (i.e. its number) given its label
            string get_name(node_t n) {
                if (n.name == "I") return "I";                          // Skip the artificial "I" node as it has no label
                return substr(n.label, 0, index(n.label, ":#"));        // Return the name
            }

            // Get the count of a node given its label
            int get_count(node_t n) {
                if (n.name == "I") return "I";                          // Skip the artificial "I" node as it has no label
                return substr(n.label, rindex(n.label, "#") + 1);       // Return the count
            }

            // Get the number of a node (the decimal integer) given its label
            string get_num(node_t n) {
                if (n.name == "I") return "I";                          // Skip the artificial "I" node as it has no label
                string label = gsub(gsub(n.label, "\r"), "\n", "|");    // Put the label on one line
                int start_cut = rindex(label, "|") + 1;                 // Find the starting index of the cut
                int end_cut = rindex(label, " #");                      // Find the ending index of the cut
                return substr(label, start_cut, end_cut - start_cut);   // Return the (decimal) number of the node
            }

            // Get the number of a node (the decimal integer) and its count given its label
            string get_num_and_count(node_t n) {
                if (n.name == "I") return "I";                          // Skip the artificial "I" node as it has no label
                string label = gsub(gsub(n.label, "\r"), "\n", "|");    // Put the label on one line
                return substr(label, rindex(label, "|") + 1);           // Return the (decimal) number and the count of the node
            }

            // Get the red parent of a node in a given graph. If the node has no red parent, NULL is returned
            edge_t get_red_parent(graph_t g, node_t n) {
                edge_t inc_edge = fstedge_sg(g, n);
                // While it is not an incoming edge with a "firebrick" endpoint, continue (unless the edge is NULL)
                while (inc_edge != NULL && (inc_edge.head.name != n.name || index(inc_edge.tail.fillcolor, "'"$red_prefix"'") == -1)) {      
                    inc_edge = nxtedge_sg(g, inc_edge, n);
                }
                return inc_edge;
            }
            

            // Create "before" and "after" graphs
            graph_t before = graph("'"$merge_before"'", "D");
            graph_t after = graph("'"$merge_after"'", "D");

            // Make the rendering more consistent
            before.ordering = "out";
            after.ordering = "out";

            // Collect the children of the merged blue node that have been merged during the determinization and also the edge labels
            graph_t graph_det = graph("Determinization", "D");
            string merged_during_det = "";

         }

         // First iteration, when the graph "before" is the current graph and the graph "after" is the next graph
         N [ $NG != NULL ] { 
            node_t node2 = isNode($NG, $.name);                         // Corresponding node in the graph "after"

            if (node2 != NULL && ($.label != node2.label || $.degree != node2.degree)) {  // Consider a node only if an actual merge has occurred
                // Clone the current and the corresponding nodes to the "before" and "after" graphs respectively
                clone(before, $); 
                clone(after, node2); 

                // Add all incoming edges of the current node with their endpoints to the graph "before" to create a context (tail -> head)
                edge_t edge1 = fstedge_sg($G, $);
                while (edge1 != NULL) {
                    if ($.name == edge1.head.name) clone(before, edge1);
                    edge1 = nxtedge_sg($G, edge1, $);
                }

                // Add all incoming edges of the corresponding node with their endpoints to the graph "after" to create a context (tail -> head)
                edge_t edge2 = fstedge_sg($NG, node2);
                while (edge2 != NULL) {
                    if (node2.name == edge2.head.name) clone(after, edge2);
                    edge2 = nxtedge_sg($NG, edge2, node2);
                }

                // Collect the nodes that have been merged during determinization (excluding the initial blue node with red parent)
                if (get_representative(node2) != get_representative($) && get_red_parent(after, isNode(after, node2.name)) == NULL) {
                    clone(graph_det, node2);
                }
            }
        }

        END {
            // Skip empty graphs (for which no merges have actually occurred)
            if (nNodes(before) > 0 && nNodes(after) > 0) {
                // Find red and blue nodes that have actually been merged (initially)
                node_t blue_after = fstnode(after);
                node_t blue_before = isNode(before, blue_after.name);

                while (blue_after != NULL) {
                    // Find the main merged blue node: a blue node that has changed its representative and has a red parent
                    if (blue_after.fillcolor == "'"$blue"'" && get_representative(blue_after) != get_representative(blue_before) && get_red_parent(after, blue_after) != NULL) {
                        node_t red_after = fstnode(after);
                        node_t red_before = isNode(before, red_after.name);

                        int found = 0;
                        while (red_after != NULL) {
                            // Find the main merged red node: the representative of the found blue node
                            if (red_after.fillcolor == "'"$red"'" && get_representative(blue_after) == get_name(red_after)) {
                                edge_t parent_edge_blue = get_red_parent(after, blue_after);   // Cannot be NULL - has been checked above
                                edge_t parent_edge_red = get_red_parent(after, red_after);     // Cannot be NULL by the properties of the algorithm

                                // Find the nodes that have been merged during the determinization process
                                node_t node_det_copy = fstnode(graph_det);
                                while (node_det_copy != NULL) {
                                    node_t node_det = isNode(after, node_det_copy.name);
                                    node_t repr_det = fstnode(after);

                                    while (repr_det != NULL) {
                                        if (get_representative(node_det) == get_name(repr_det)) {

                                            // Find the incoming edges on which the nodes have been merged
                                            // An incoming edge whose other endpoint has been affected by determinization or is the initially merged blue node
                                            edge_t edge_det_blue = fstedge_sg(after, node_det);
                                            string parent_repr_name = get_representative(edge_det_blue.tail);
                                            while (edge_det_blue.head != node_det || (isNode(graph_det, edge_det_blue.tail.name) == NULL && edge_det_blue.tail.name != blue_after.name)) {
                                                edge_det_blue = nxtedge_sg(after, edge_det_blue, node_det);
                                                parent_repr_name = get_representative(edge_det_blue.tail);
                                            }

                                            // An incoming edge whose other endpoint is the representative of `edge_det_blue.tail` (parent of `node_det`) or is already a red node
                                            edge_t edge_det_red = fstedge_sg(after, repr_det);
                                            while (edge_det_red.head != repr_det || (get_name(edge_det_red.tail) != parent_repr_name && edge_det_red.tail.fillcolor != "'"$red"'")) {
                                                edge_det_red = nxtedge_sg(after, edge_det_red, repr_det);
                                            }

                                            // Colour the nodes merged during the determinization process (and their incoming edges) into `colour_det_merge`
                                            // Additionally, make them slightly thicker (`thickness_det_merge`)
                                            repr_det.penwidth = '"$thickness_det_merge"'; repr_det.color = "'"$colour_det_merge"'"; 
                                            node_det.penwidth = '"$thickness_det_merge"'; node_det.color = "'"$colour_det_merge"'";

                                            edge_det_blue.penwidth = '"$thickness_det_merge"'; edge_det_blue.color = "'"$colour_det_merge"'";
                                            edge_det_red.penwidth = '"$thickness_det_merge"'; edge_det_red.color = "'"$colour_det_merge"'";

                                            // Make the merged children of the blue node (and their incoming edges) dashed, unless it is the merged blue node itself
                                            if (node_det.name != blue_after.name) {
                                                node_det.style = "filled,dashed";
                                                edge_det_blue.style = "dashed";
                                            }

                                            // Get the label of the incoming edge to log it
                                            string inc_edge_det_label = gsub(gsub(edge_det_blue.label, "\r"), "\n");

                                            // Add the information about this merge for the logging
                                            merged_during_det += get_num_and_count(node_det) + " and " +
                                                    get_num(repr_det) + " #" + (string)(get_count(repr_det) - get_count(node_det)) +
                                                    " on " + inc_edge_det_label + ", ";
                                            break;
                                        }
                                        repr_det = nxtnode_sg(after, repr_det);
                                    }
                                    node_det_copy = nxtnode_sg(graph_det, node_det_copy);
                                }

                                // Cut the trailing ", " if at least one node has been merged during determinization, otherwise write "-"
                                if (merged_during_det != "") merged_during_det = substr(merged_during_det, 0, rindex(merged_during_det, ", "));
                                else merged_during_det = "-";

                                // Colour the initial merged states much darker and make font `ghostwhite`
                                // Additionally, make the border of these nodes much thicker (`thickness_init_merge`), colour them into `colour_init_merge`, and make the merged blue node dashed
                                blue_after.fillcolor = "'"$dark_blue"'"; blue_after.fontcolor = "'"$white"'"; blue_after.color = "'"$colour_init_merge"'"; blue_after.penwidth = '"$thickness_init_merge"'; blue_after.style = "filled,dashed";
                                red_after.fillcolor = "'"$dark_red"'"; red_after.fontcolor = "'"$white"'"; red_after.color = "'"$colour_init_merge"'"; red_after.penwidth = '"$thickness_init_merge"';

                                // Apply the same colouring and thickness to the original nodes (before the merge)
                                blue_before.fillcolor = "'"$dark_blue"'"; blue_before.fontcolor = "'"$white"'"; blue_before.color = "'"$colour_init_merge"'"; blue_before.penwidth = '"$thickness_init_merge"';
                                red_before.fillcolor = "'"$dark_red"'"; red_before.fontcolor = "'"$white"'"; red_before.color = "'"$colour_init_merge"'"; red_before.penwidth = '"$thickness_init_merge"';

                                // Colour the incoming edges on which the red and blue nodes have been merged into `colour_init_merge` and make them much thicker (`thickness_init_merge`)
                                // Also, make the incoming edge of the blue node dashed
                                parent_edge_blue.color = "'"$colour_init_merge"'"; parent_edge_blue.penwidth = '"$thickness_init_merge"'; parent_edge_blue.style = "dashed";
                                parent_edge_red.color = "'"$colour_init_merge"'"; parent_edge_red.penwidth = '"$thickness_init_merge"';

                                // Apply the same colouring and thickness to the edge on which the red and blue nodes have been merged in the graph "before"
                                edge_t parent_edge_blue_before = get_red_parent(before, blue_before); parent_edge_blue_before.color = "'"$colour_init_merge"'"; parent_edge_blue_before.penwidth = '"$thickness_init_merge"';
                                edge_t parent_edge_red_before = get_red_parent(before, red_before); parent_edge_red_before.color = "'"$colour_init_merge"'"; parent_edge_red_before.penwidth = '"$thickness_init_merge"';

                                // Get the label of this incoming edge
                                string mcat_mserv = gsub(gsub(parent_edge_blue.label, "\r"), "\n");  // Remove \r and \n from the edge label

                                // Log the information about this merge
                                string red_node_type = "";
                                if (get_count(red_before) < '"$sink_count"') red_node_type = "RED SINK";
                                else red_node_type = "red";

                                string blue_node_type = "";
                                if (get_count(blue_before) < '"$sink_count"') blue_node_type = "BLUE SINK";
                                else blue_node_type = "blue";

                                print("Merged " + get_num_and_count(red_before) + " (" + red_node_type + ") and " + get_num_and_count(blue_before) + " (" + blue_node_type + ") on " +
                                    mcat_mserv + ". Merged during determinization: " + merged_during_det + " (merge '"$t"', page '"$curr_page"')");

                                found = 1;
                                break;
                            }
                            red_after = nxtnode_sg(after, red_after);
                            red_before = isNode(before, red_after.name);
                        }
                        // Break the loop if the merged red and blue states have already been found
                        if (found == 1) break;
                    }
                    blue_after = nxtnode_sg(after, blue_after);
                    blue_before = isNode(before, blue_after.name);
                }

                // Write the graphs to the temporary DOT files
                writeG(before, "'"$merge_before_dot"'"); 
                writeG(after, "'"$merge_after_dot"'");
            } else {
                // Report that no merges have occurred in this iteration
                print("No merges have occurred -- skipping");
            }
        }' "$test1" "$test2" | tee -a "$log_file"

    # If a merge has occurred, render the generated graphs
    if [[ -f "$merge_before_dot" ]]; then
        # Render the graphs into separate PNG images
        dot -Tpng -Glabel="Merge ${t}: Before" "$merge_before_dot" -o "$merge_before_png" 
        dot -Tpng -Glabel="Merge ${t}: After" "$merge_after_dot" -o "$merge_after_png"

        # (Horizontally) Combine the graphs to one PNG image
        convert -append "$merge_before_png" "$merge_after_png" "$merge_png"

        # Remove the separate PNG and DOT files of the graphs (they are not needed anymore)
        rm "$merge_before_dot" "$merge_after_dot" "$merge_before_png" "$merge_after_png" 

        curr_page=$((curr_page + 1))
    fi

    echo "---------" | tee -a "$log_file"
done

# Combine all merges into one PDF file (A1 format)
echo "Combining all merges into one PDF file..." | tee -a "$log_file"

find . -maxdepth 1 -type f -name '*merge*.png' | sort | xargs -r img2pdf --pagesize A1^T -o "$out" 2> /dev/null

# Remove the separate PNG files with merges
rm merge*.png
